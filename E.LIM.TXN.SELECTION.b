* @ValidationCode : MjoxNDE3MDk0Mjk5OkNwMTI1MjoxNTY4MjY5MTMyNDgzOnJhamFrOjM6MDowOjE6ZmFsc2U6Ti9BOkRFVl8yMDE5MDguMjAxOTA3MjMtMDI1MTo1MzQ6MjEx
* @ValidationInfo : Timestamp         : 12 Sep 2019 11:48:52
* @ValidationInfo : Encoding          : Cp1252
* @ValidationInfo : User Name         : rajak
* @ValidationInfo : Nb tests success  : 3
* @ValidationInfo : Nb tests failure  : 0
* @ValidationInfo : Rating            : N/A
* @ValidationInfo : Coverage          : 211/534 (39.5%)
* @ValidationInfo : Strict flag       : true
* @ValidationInfo : Bypass GateKeeper : false
* @ValidationInfo : Compiler Version  : DEV_201908.20190723-0251
* @ValidationInfo : Copyright Temenos Headquarters SA 1993-2021. All rights reserved.

* Version 2 15/05/01  GLOBUS Release No. G12.0.00 29/06/01
*-----------------------------------------------------------------------------
* <Rating>2095</Rating>
*-----------------------------------------------------------------------------
$PACKAGE LI.ModelBank

SUBROUTINE E.LIM.TXN.SELECTION(Y.ID.LIST)
*-----------------------------------------------------------------------------
*
** As FORMLIST is not compiling under release 5 processing added to
** write away a select list and to read it. Open of savedlists also
** included. 14/08/89 RCD.
**** =============================================================== ****
**** Prepares a list of limit transaction keys or possible keys      ****
**** The possible list allows for Commitment contract details to be  ****
**** displayed by the Lim.Txn enquiry                                ****
**** =============================================================== ****
***************************************************************************
*                        MODIFICATION LOG
*                        ----------------
*
*  29/12/04 - CI_10025962
*            This routine has a bug when forming the Y.SEL.CRITERIA string
*            when more than one selection criteria is given and one of them
*            is having the operand as "ALL". For this fix done in the para
*            BUILD.SEL.
*
* 18/10/05 - CI_10035723
*            GET-LIST fails in socket connections and the enquiry hangs without
*            displaying the results. Hence, GET-LIST replaced with GETLIST.
*
* 12/04/06 - CI_10040493
*            The fields REF.NO and SER.NO are not formatted properly and this
*            leads to the enquiry returning wrong results.
*
* 17/08/07 - CI_10050862
*            When enq LIAB is executed for a customer, who is liable to himself,
*            upon drilling down the Global level limits,(LIAB->LIM.TRADE->LIM.CUST->
*            LIM.TXN), finally in LIM.TXN, the txns result under his own liablity
*            limit is duplicated. Fix done to resolve this.
*
* 05/11/08 - BG_100020706
*            When 'WRITE' command is used, it first writes into buffer.
*            After the transaction gets over it physically write into the disk.
*            In this routine, select statement is written into VOC using 'WRITE'
*            and from there it is executed.
*
*            When drilling into a link for the first time enquiry does not display
*            the correct page. Because the select statement will be written into VOC
*            only after the transaction gets over.
*
*            Going back and drilling into the same link again, displays the page
*            correctly. Because the select statement generated by the previous
*            process is written to the VOC at the end of the previous
*            transaction management.
*
*            Hence code is changed to execute select statement without writing into VOC
*
* 26/02/09 -  CI_10060997(CSS REF:HD0906053)
*             Duplication problem during drilldown is solved by correcting the code
*             changes done through cd CI_10035723.Changes done through cd CI_10050862 is removed.
*
* 06/05/10 - RTC WORK ITEM
*            Replaced EXECUTE command with DAS
*
* 18/10/10 - Task - 84420
*            Replace the enterprise(customer service api)code into  Banking framework related
*            routines which reads CUSTOMER.
*
* 16/02/11 - Defect 119200 / Task 155239
*            Uninitialised variable error while running enquiry LIM.TXN
*            causes error display in browser.
*
* 29/11/12 - CI_10075159 / Task 380963
*            When enq LIAB is executed for a customer, who is liable to himself,
*            upon drilling down the Global level limits,(LIAB->LIM.TRADE->LIM.CUST->LIM.TXN)
*            in LIMIT.TXN it takes more time to display the output.
*
* 30/04/12 - Defect - 394580/ Task - 397672
*            When enq LIM.TXN is executed, system takes more time to display the output.
*            ID level selection is added in SELECT query to increase the performance.
*
* 08/05/13 - Defect 986559 / Task 992303
*            While running the LIM.TXN enquiry for the sub group limits, then the transaction details
*            are fetched from the parent group limit
*
* 02/07/14 - Defect 1026757 / Task 1045416
*             In the ENQUIRY LAIB when you are drilling down the ENQ LIM.TXN CUSTOMER.NO field set to ALL
*             then the selection criteria is done based on the CHECK.CUST which is I descriptor variable .
*             As the client in TAFJ environments I descriptors variable will not work. So the reported problem happened,
*             Hence the IDESC field logic is done in here which checks two other IDESC field LIAB.NO and CUST.NO.
*
* 16/07/14 - Defect 986559 / Task 1059394
*            While running the LIM.TXN enquiry for the sub group limits, then the Customer number
*            should be displayed as the Master group instead of null values
*
* 12/02/15 - Defect:1250871 / Task: 1252690
*            !HUSHIT is not supported in TAFJ, hence changed to use HUSHIT().
*
* 15/06/17 - Defect 1977286 / Task 2164951
*            When limits of liability customer doesnt have a child limit, then system not fetching
*            proper record while running LIM.TXN enquiry or drilling drown through LIAB enquiry.
*            Changes done to remove GETLIST , due to which DAS is not fetching correct results.
*
* 21/08/17 - EN 2205157 / Task 2237727
*            use API instead of direct I/O for LIMIT related files
*            LIMIT.LIABILITY, LIMIT.LINES
*
* 08/11/17 - EN 2322180 / Task 2322183
*            Support for new limit key and customer group id
*
* 04/12/17 - EN_2287989 / Task 2292817
*            Under Validation/Utilisation structure, If Validation type of limit is being processed,
*            then pass all the underlying utilisation limit id's as selection id's.
*
* 23/11/18 - Defect 2857427 / Task 2868962
*            Files starting as LMTN... piling up under UD/&SAVEDLIST&
*            System is generating logs in UD/&SAVELIST& starting with LMTN.... on daily basis.
*
* 04/09/19 - Defect 3314284 / Task 3320094
*            Display LIMIT.TXNS appropriately for new limit keys.
*
* 11/09/19 - Enhancement 3297004 / Task 3297005
*            Formatting changes of limit products for numeric and non-numeric keys.
**************************************************************************************************************

    $INSERT I_CustomerService_Parent
    $INSERT I_DAS.LIMIT
    $INSERT I_DAS.LIMIT.LIABILITY

    $USING LI.GroupLimit
    $USING EB.DataAccess
    $USING LI.Config
    $USING EB.SystemTables
    $USING EB.Reports

*
**** =============================================================== ****
MAIN.PARA:
*--------
*
    customerParent = "" ;* To avoid variable initialisation warning
    Y.ID.LIST = ''
    Y.CUST.NO.FLAG = 0
    Y.REQUEST.LIAB = ''
    Y.REQUEST.CUST = ''
    IF EB.Reports.getDLogicalOperands()<1> = '' THEN RETURN
    SQ = "'"
*
    GOSUB OPEN.ALL.FILES:

* The transaction details are fetched based on the variables D.FIELDS, D.LOGICAL.OPERANDS and D.RANGE.AND.VALUE
* In case of the subgroup limits, these variables are changed to get the master group limit transaction
* So these variables are stored in the old variable
* Instead on saving the value and restore, values are taken to a local array to use in the routine.
    D.FIELDS.DET = ''
    D.LOGICAL.DET = ''
    D.RANGE.AND.VALUE.DET = ''

    D.FIELDS.DET = EB.Reports.getDFields()
    D.LOGICAL.OPERANDS.DET = EB.Reports.getDLogicalOperands()
    D.RANGE.AND.VALUE.DET = EB.Reports.getDRangeAndValue()

* On running the enquiry for the sub group limits,

    IF D.RANGE.AND.VALUE.DET<1>[1,1] EQ 'S' THEN
        GOSUB PROCESS
    END


    GOSUB PROCESS.LIMITS

RETURN

**** ============================================================== ****

PROCESS.LIMITS:
*--------------
*
****  Main processing.
**** Store passed parameters
*

    GOSUB SET.UP.PARAMS
*
**** Set up list of keys for Limit.Txns file
*
    GOSUB PROCESS.PARAMS
*
RETURN
*
**** =============================================================== ****

PROCESS:
*-------

* If it is a sub group limit, then the master group limit is formed and then
* the transaction details are processed from this master group limit


    SUB.GROUP.ID = D.RANGE.AND.VALUE.DET<1>
    SUB.GRP.PRODUCT = D.RANGE.AND.VALUE.DET<2>
    SER.NO = D.RANGE.AND.VALUE.DET<3>

* With the sub group Id availabe in the sub group limit, the sub group details are
* read from the LIMIT.SHARING.GROUP application.

    YR.SUB.GRP = ''
    YR.SUB.GRP = LI.GroupLimit.LimitSharingGroup.Read(SUB.GROUP.ID, LSG.ERR)
* Master group Id and the allowed customer are got the LIMIT.SHARING.GROUP record
* While the product and serial number are got from the sub group limit Id

    IF YR.SUB.GRP THEN

        ALLOWED.CUST = YR.SUB.GRP<LI.GroupLimit.LimitSharingGroup.SgAllowedCustomer>
        MASTER.KEY = YR.SUB.GRP<LI.GroupLimit.LimitSharingGroup.SgParentGroup>

    END

* The master group limit is formed to get the transaction details
* The master group information is passed in the D.RANGE.AND.VALUE, D.LOGICAL.OPERANDS,
* D.FIELDS variables so that it is used to fetch the transaction details


    D.RANGE.AND.VALUE.DET<1> = MASTER.KEY
    D.RANGE.AND.VALUE.DET<2> = SUB.GRP.PRODUCT
    D.RANGE.AND.VALUE.DET<3> = SER.NO

* Changed the D.RANGE.AND.VALUE same as that of the Master group when running for the
* Sub group. This avoids the display of the Customer number correctly instead of null value


RETURN

OPEN.ALL.FILES:
*-------------
*
****  Open all files required for processing.
*
*
    OPEN '','&SAVEDLISTS&' TO F.SAVEDLISTS ELSE
        EB.Reports.setEnqError('UNABLE TO OPEN &SAVEDLISTS&')
        GOTO PROGRAM.ABORT
    END
*
RETURN
*
**** =============================================================== ****
SET.UP.PARAMS:
*----------------
*
**** Sets up tables of field operands and values etc. depending on the
**** common variables passed.
**** D.FIELDS & D.LOGICAL.OPERANDS & D.RANGE.AND.VALUE.
*
    Y.PAR.EQ= 0
    Y.LIAB.OTH = ""
    Y.REF.PRES = ""
    Y.SER.PRES = ""
    Y.CUST.PRES = ""
    Y.OPERAND = ""
    Y.CHK.VALUE = ""
    YCOUNT = COUNT(D.FIELDS.DET, @FM) + 1
    PROCESS.NEW.LIMIT = 0
    FOR YX = 1 TO YCOUNT
        Y.WRK.FIELDS = D.FIELDS.DET<YX>
        Y.WRK.OPERAND = D.LOGICAL.OPERANDS.DET<YX>
        Y.WRK.CHK.VALUE = D.RANGE.AND.VALUE.DET<YX>
        Y.CHK.NO = COUNT(Y.WRK.CHK.VALUE<1,1>, @SM) + 1
        BEGIN CASE
            CASE Y.WRK.FIELDS = 'LIAB.NO'
                Y.OPERAND<1> = Y.WRK.OPERAND
                Y.CHK.VALUE<1> = Y.WRK.CHK.VALUE
                IF Y.WRK.CHK.VALUE[1,2] = "LI" THEN
                    PROCESS.NEW.LIMIT = 1 ;* Flag to indicate processing for New type of limit id
                END
                IF Y.WRK.OPERAND EQ 1 AND Y.CHK.NO EQ 1 THEN
                    IF Y.WRK.CHK.VALUE NE "ALL" AND Y.WRK.CHK.VALUE NE "" THEN
                        Y.PAR.EQ += 1
                    END
                END
            CASE Y.WRK.FIELDS = 'REF.NO'
                IF Y.WRK.CHK.VALUE NE "ALL" AND Y.WRK.CHK.VALUE NE "" AND NUM(Y.WRK.CHK.VALUE) THEN
                    Y.WRK.CHK.VALUE = FMT(Y.WRK.CHK.VALUE,"7'0'R")
                END
                Y.OPERAND<2> = Y.WRK.OPERAND
                Y.CHK.VALUE<2> = Y.WRK.CHK.VALUE
                Y.REF.PRES = 1
                Y.LIAB.OTH = 1
                IF Y.WRK.OPERAND EQ 1 AND Y.CHK.NO EQ 1 THEN
                    IF Y.WRK.CHK.VALUE NE "ALL" AND Y.WRK.CHK.VALUE NE "" THEN
                        Y.PAR.EQ += 2
                    END
                END
            CASE Y.WRK.FIELDS = 'SER.NO'
                IF Y.WRK.CHK.VALUE NE "ALL" AND Y.WRK.CHK.VALUE NE "" THEN
                    Y.WRK.CHK.VALUE = FMT(Y.WRK.CHK.VALUE,"2'0'R")
                END
                Y.OPERAND<3> = Y.WRK.OPERAND
                Y.CHK.VALUE<3> = Y.WRK.CHK.VALUE
                Y.SER.PRES = 1
                Y.LIAB.OTH = 1
                IF Y.WRK.OPERAND EQ 1 AND Y.CHK.NO EQ 1 THEN
                    IF Y.WRK.CHK.VALUE NE "ALL" AND Y.WRK.CHK.VALUE NE "" THEN
                        Y.PAR.EQ += 4
                    END
                END
            CASE Y.WRK.FIELDS = 'CUST.NO'
                Y.OPERAND<4> = Y.WRK.OPERAND
                Y.CHK.VALUE<4> = Y.WRK.CHK.VALUE
                Y.CUST.PRES = 1
                Y.LIAB.OTH = 1
                Y.CUST.NO.FLAG = 1
                IF Y.WRK.OPERAND EQ 1 AND Y.CHK.NO EQ 1 THEN
                    IF Y.WRK.CHK.VALUE EQ "ALL" THEN
                        Y.PAR.EQ += 1
                    END ELSE
                        IF Y.WRK.CHK.VALUE NE '' THEN
                            Y.PAR.EQ +=2
                        END
                    END
                END
        END CASE
    NEXT YX
*
RETURN
*
**** =============================================================== ****
PROCESS.PARAMS:
*----------------
*
**** Proccess passed parameters in order to set a list of keys for
**** the Limit.txns file the keys for this file consit of
**** Liability no.Limit reference no.Serial no.Customer no
    Y.SEL.COMMAND = ''
    Y.SEL.CRITERIA = ''
    BEGIN CASE
        CASE PROCESS.NEW.LIMIT ;* When we have new limit id (TXN.REF id) get details from limit record
            RLimit = '' ; limitReadErr = '' ; Y.LHB.REC = '' ; ID.LIST = '' ; ID.LIST.CNT = '' ; Y.ID.LIST = ''
            LIMIT.KEY = Y.CHK.VALUE<1>
            LI.Config.LimitRead(LIMIT.KEY, RLimit, "", limitReadErr)
            IF RLimit<LI.Config.Limit.LimitType> EQ '2' THEN     ;*If Validation type of limit, pass the underlying utilisation limit id's as selection id's
                Y.LHB.REC = LI.Config.LimitHierarchyBalances.Read(LIMIT.KEY, '')
                ID.LIST = RAISE(Y.LHB.REC<LI.Config.LimitHierarchyBalances.LimitId>)
                DEL ID.LIST<1>                             ;* Remove first position which will hold the validation limit id itself.
                ID.LIST.CNT = DCOUNT(ID.LIST, @FM)         ;* Count the number of utilisation limits under the validation limit.
            END ELSE
                ID.LIST = LIMIT.KEY
                ID.LIST.CNT = 1
            END
        
            FOR ID.CNT = 1 TO ID.LIST.CNT
                RLimit = '' ; limitReadErr = '' ; TMP.Y.ID.LIST = ''
                LIMIT.KEY = ID.LIST<ID.CNT>
                LI.Config.LimitRead(LIMIT.KEY, RLimit, "", limitReadErr)
                BEGIN CASE
                    CASE RLimit<LI.Config.Limit.JointLiability> = "YES" ;* Joint customer Limit txn id is Limit id
                        Y.ID.LIST<-1> = LIMIT.KEY
                    CASE RLimit<LI.Config.Limit.LiabilityNumber> ;* Individual limit with Liab number , txn id is LIMIT ID.LIAB ID
                        Y.ID.LIST<-1> = LIMIT.KEY:'.':RLimit<LI.Config.Limit.LiabilityNumber>
                    CASE RLimit<LI.Config.Limit.CustomerNumber> ;* Multi customer limit, txn id is LIMIT_ID.CUST_ID_1, LIMIT_ID.CUST_ID_2, LIMIT_ID.CUST_ID_3...
                        CUST.CNT = DCOUNT(RLimit<LI.Config.Limit.CustomerNumber>,@VM)
                        TMP.Y.ID.LIST = STR(@VM:LIMIT.KEY,CUST.CNT) ;* Repeat limit id to be number of customer ids
                        DEL TMP.Y.ID.LIST<1,1> ;* Get rid of first VM (blank space)
                        TMP.Y.ID.LIST = SPLICE(TMP.Y.ID.LIST,'.',RLimit<LI.Config.Limit.CustomerNumber>) ;* Concat customer ids to limit id
                        TMP.Y.ID.LIST = RAISE(TMP.Y.ID.LIST) ;* Finally raise and pass the list of LIMIT.TXN ids seperated by FMs
                        Y.ID.LIST<-1> = TMP.Y.ID.LIST
                END CASE
            NEXT ID.CNT
            
        CASE Y.PAR.EQ = 8 OR Y.PAR.EQ = 9
            Y.LINE.ID = Y.CHK.VALUE<1>:'.'
            Y.WRK.LINE = Y.CHK.VALUE<2>
            IF (Y.PAR.EQ EQ 8) AND NUM(Y.WRK.LINE) THEN
                Y.WRK.LIN2 = Y.WRK.LINE * 1
                YLEN = LEN(Y.WRK.LIN2)
                IF Y.WRK.LIN2 GT '9999' THEN
                    Y.WRK.LINE = Y.WRK.LIN2[1,YLEN-4]:"0000"
                END ELSE
                    IF Y.WRK.LIN2 GT '99' THEN
                        Y.WRK.LINE = Y.WRK.LIN2[1,YLEN-2]:"00"
                    END
                END
            END
            IF NUM(Y.WRK.LINE) THEN
                Y.WRK.LINE = FMT(Y.WRK.LINE,"7'0'R")
            END
            Y.LINE.ID := Y.WRK.LINE:'.'
            Y.WRK.LINE = Y.CHK.VALUE<3>
            Y.WRK.LINE = FMT(Y.WRK.LINE,"2'0'R")
            Y.LINE.ID := Y.WRK.LINE
            IF Y.PAR.EQ EQ 8 THEN
                GOSUB PROCESS.LIM.LINES
                IF Y.WRK.CHK.VALUE NE "" AND Y.WRK.OPERAND<1> EQ "1" THEN ;* ID level selection of limit for liable customer
                    Y.FIELD.NAME="@ID"
                    Y.WRK.OPERAND="6"
                    Y.WRK.CHK.VALUE=Y.CHK.VALUE<1>:"...."            ;* "LIKE" opeerand hard coded
                    GOSUB BUILD.SEL
                END
                Y.FIELD.NAME = 'LIAB.NO'
                Y.WRK.OPERAND = Y.OPERAND<1>
                Y.WRK.CHK.VALUE = Y.CHK.VALUE<1>
                Y.REQUEST.LIAB = Y.WRK.CHK.VALUE
                GOSUB BUILD.SEL
                IF Y.REF.PRES THEN
                    Y.FIELD.NAME = 'REF.NO'
                    Y.WRK.OPERAND = Y.OPERAND<2>
                    Y.WRK.CHK.VALUE = Y.CHK.VALUE<2>
                    GOSUB BUILD.SEL
                END
                IF Y.SER.PRES THEN
                    Y.FIELD.NAME = 'SER.NO'
                    Y.WRK.OPERAND = Y.OPERAND<3>
                    Y.WRK.CHK.VALUE = Y.CHK.VALUE<3>
                    GOSUB BUILD.SEL
                END
                Y.REQUEST.CUST = Y.CHK.VALUE<4>
                GOSUB CHECK.CUST
                GOSUB SEL.LIMIT
*
            END ELSE
                Y.ID.LIST<1> = Y.LINE.ID:'.':Y.CHK.VALUE<4>
            END
*
        CASE NOT(Y.LIAB.OTH)
            Y.WRK.OPERAND = Y.OPERAND<1>
            Y.WRK.CHK.VALUE = Y.CHK.VALUE<1>
            IF Y.WRK.OPERAND = 1 AND Y.WRK.CHK.VALUE<1,1> NE 'ALL' THEN
**** Equal to one or more selected liabilty numbers.
                GOSUB MAT.LIAB.EQUAL:
            END ELSE
                GOSUB MAT.LIAB.OTHERS:
            END
        CASE 1
            Y.WRK.OPERAND = Y.OPERAND<1>
            Y.WRK.CHK.VALUE = Y.CHK.VALUE<1>
            IF Y.WRK.OPERAND = 1 AND Y.WRK.CHK.VALUE<1,1> NE 'ALL' THEN
**** Equal to one or more selected liabilty numbers.
                GOSUB MAT.LIAB.EQUAL:
            END ELSE
                GOSUB MAT.LIAB.OTHERS:
            END
            Y.SEL.CRITERIA = ''
* Add @ID in select to increase performance
            IF Y.WRK.OPERAND EQ "1" THEN
                Y.FIELD.NAME="@ID"
                Y.WRK.OPERAND="6"         ;* "LIKE" operand hard coded
                Y.WRK.CHK.VALUE=Y.CHK.VALUE<1>:"...."
                GOSUB BUILD.SEL
            END
            Y.FIELD.NAME = 'LIAB.NO'
            Y.WRK.OPERAND = Y.OPERAND<1>
            Y.WRK.CHK.VALUE = Y.CHK.VALUE<1>
            Y.REQUEST.LIAB = Y.WRK.CHK.VALUE
            GOSUB BUILD.SEL
            IF Y.REF.PRES THEN
                Y.FIELD.NAME = 'REF.NO'
                Y.WRK.OPERAND = Y.OPERAND<2>
                Y.WRK.CHK.VALUE = Y.CHK.VALUE<2>
                GOSUB BUILD.SEL
            END
            IF Y.SER.PRES THEN
                Y.FIELD.NAME = 'SER.NO'
                Y.WRK.OPERAND = Y.OPERAND<3>
                Y.WRK.CHK.VALUE = Y.CHK.VALUE<3>
                GOSUB BUILD.SEL
            END
            IF Y.CUST.PRES THEN
                Y.REQUEST.CUST = Y.CHK.VALUE<4>
                GOSUB CHECK.CUST
            END
            GOSUB SEL.LIMIT
*
    END CASE
RETURN
**** =============================================================== ****
CHECK.CUST:
*---------------
* IDESC field CHECK.CUST not working in TAFJ environment which is based on other 2 IDESC fields ,
* Hence the logic behind this IDESC field is done here based on the CUST.NO IDESC field.
*
    IF Y.REQUEST.CUST NE 'ALL' AND NUM(Y.REQUEST.CUST) THEN
        customerId = Y.REQUEST.CUST
        customerParent = ''
* get the customer liability by calling customer service api.
        CALL CustomerService.getParent(customerId, customerParent)
    END

    IF Y.REQUEST.LIAB NE 'ALL' AND NUM(Y.REQUEST.LIAB) THEN
        liabId = Y.REQUEST.LIAB
        liabParent = ''
* get the customer liability by calling customer service api.
        CALL CustomerService.getParent(liabId, liabParent)
    END

    BEGIN CASE
*Select the CUST.NO IDESC field if the Customer is under the limit liability group
*and also if it is self liability customer
        CASE Y.REQUEST.CUST EQ Y.REQUEST.LIAB AND customerParent<Parent.customerLiability> EQ Y.REQUEST.LIAB
            GOSUB SEL.CUS
*Select the CUST.NO IDESC field if the Customer is under the limit liability group
*and also if liability customer and customer is not same
        CASE Y.REQUEST.CUST NE Y.REQUEST.LIAB AND customerParent<Parent.customerLiability> EQ Y.REQUEST.LIAB
            GOSUB SEL.CUS
*Select the CUST.NO IDESC field to select all limits for a given liability customer
        CASE Y.REQUEST.CUST EQ 'ALL' AND NUM(Y.REQUEST.LIAB) AND liabParent<Parent.customerLiability>
            GOSUB SEL.CUS
*Select the CUST.NO IDESC field to select all the limits for a given customer.
        CASE Y.REQUEST.LIAB EQ 'ALL' AND NUM(Y.REQUEST.CUST) AND customerParent<Parent.customerLiability>
            GOSUB SEL.CUS
    END CASE

RETURN
**** =============================================================== ****
SEL.CUS:
*---------------
* Select the LIMIT record with the CUST.NO IDESC field.

    Y.WRK.OPERAND = Y.OPERAND<4>
    Y.WRK.CHK.VALUE = Y.CHK.VALUE<4>
    Y.FIELD.NAME = 'CUST.NO'
    GOSUB BUILD.SEL

RETURN
**** =============================================================== ****
MAT.LIAB.EQUAL:
*---------------
*
**** If operand is 'EQ', select on Limit liability file can be avoided.
*
    Y.I = 0
    LOOP
        Y.I += 1
        Y.CUST.ID = Y.CHK.VALUE<1,1,Y.I>
    WHILE Y.CUST.ID NE ''
        GOSUB PROCESS.LIM.LIAB
    REPEAT
RETURN
*
**** =============================================================== ****
MAT.LIAB.OTHERS:
*-----------
*
**** Select Limit liability file depending on the operand...
*
*
* Replace the keyword NULL with '' in the user list. This allows the
* user to enter EQ NULL instead of GT 0 or whatever.
*
    LOOP LOCATE 'NULL' IN Y.WRK.CHK.VALUE<1,1,1> SETTING D ELSE D = 0 UNTIL D = 0
        Y.WRK.CHK.VALUE<1,1,D> = ''
    REPEAT
*
    Y.FIELD.NAME = '@ID'
    BEGIN CASE
        CASE Y.WRK.OPERAND = 1    ;* EQual to ALL.
            NULL
        CASE Y.WRK.OPERAND = 2    ;* RG
            RG1 = Y.WRK.CHK.VALUE<1,1,1>
            RG2 = Y.WRK.CHK.VALUE<1,1,2>
            IF NOT(NUM(RG1)) THEN
                RG1 = SQ: RG1: SQ
            END
            IF NOT(NUM(RG2)) THEN
                RG2 = SQ: RG2: SQ
            END
*
            Y.SEL.CRITERIA<-1> = Y.FIELD.NAME: ' => ':  RG1: ' AND '
            Y.SEL.CRITERIA:=     Y.FIELD.NAME: ' <= ':  RG2
*
        CASE Y.WRK.OPERAND = 10   ;* NR
            RG1 = Y.WRK.CHK.VALUE<1,1,1>
            RG2 = Y.WRK.CHK.VALUE<1,1,2>
            IF NOT(NUM(RG1)) THEN
                RG1 = SQ: RG1: SQ
            END
            IF NOT(NUM(RG2)) THEN
                RG2 = SQ: RG2: SQ
            END
            Y.SEL.CRITERIA<-1> = Y.FIELD.NAME: ' < ': RG1: ' OR '
            Y.SEL.CRITERIA:=     Y.FIELD.NAME: ' > ': RG2
*
        CASE Y.WRK.OPERAND = 5    ;* NE
            Y.SEL.CRITERIA<-1> = ' '
            CONNECTION = ''
            LOOP REMOVE UD FROM Y.WRK.CHK.VALUE SETTING D
                Y.SEL.CRITERIA:= CONNECTION: Y.FIELD.NAME: ' NE ': SQ: UD: SQ
                CONNECTION = ' AND '
            UNTIL D = 0 ;* NO MORE TO REMOVE
            REPEAT
        CASE 1
            PERFORM.OPERANDS = 'EQ,XX,LT,GT,NE,LIKE,UNLIKE,LE,GE,XX'
            Y.SEL.CRITERIA<-1> = Y.FIELD.NAME: ' ': FIELD(PERFORM.OPERANDS,',',Y.WRK.OPERAND)
            Y.SEL.CRITERIA    := ' ': SQ: Y.WRK.CHK.VALUE: SQ
*
    END CASE
*
* Build selection criteria into sentence (use voc paragraph in case
* sentence exceeds maximum line length).
* Add the other selection criteria to the select command
*
    IF Y.SEL.CRITERIA THEN
        CONNECTION = 'WITH'
        LOOP REMOVE SC FROM Y.SEL.CRITERIA SETTING D UNTIL SC = ''
            Y.SEL.COMMAND:= ' ':CONNECTION: ' ': SC
            CONNECTION = '& WITH'
        REPEAT
    END
*
    THE.LIST = dasLimitLiabilityWithSelection
    THE.ARGS = Y.SEL.COMMAND:" BY @ID"
    EB.DataAccess.Das('LIMIT.LIABILITY',THE.LIST,THE.ARGS,'')
*
    IF NOT(THE.LIST) THEN
        EB.Reports.setEnqError('SELECT ON ':YF.LIMIT.LIAB:' FAILED')
        GOTO PROGRAM.ABORT
    END
*
    LOOP
        REMOVE Y.CUST.ID FROM THE.LIST SETTING CUS.POS
    WHILE Y.CUST.ID:CUS.POS
        GOSUB PROCESS.LIM.LIAB
    REPEAT
RETURN
*
**** =============================================================== ****
PROCESS.LIM.LIAB:
*----------------
**** Customer record has to be read and checked whether the customer
**** is a part of a liability group or the head of a group or a stand
**** alone customer.
    Y.LIAB.CUST = ""
    Y.LIST.UP = ""
    Y.SPARE.ID = ""
    customerId = Y.CUST.ID
    customerParent = ''
** Limit Alternative key for the customer.
    R.LIM.ALT.KEY = ""
    LIM.ALT.KEY.ERR = ""

    R.LIM.ALT.KEY = LI.Config.LimitAlternativeKey.Read(customerId, LIM.ALT.KEY.ERR)
    
* get the customer liability by calling customer service api.
    CALL CustomerService.getParent(customerId, customerParent)
*
    IF customerParent<Parent.customerLiability> EQ '' THEN
        Y.LIAB.CUST = 1
    END ELSE
        IF customerParent<Parent.customerLiability> EQ Y.CUST.ID THEN
            Y.LIAB.CUST = 2
        END
    END

    IF Y.LIAB.CUST THEN
        Y.LIMIT.LIAB = ''
        LL.ERR = ''
        LI.Config.LimitLiabilityRead(Y.CUST.ID, Y.LIMIT.LIAB, LL.ERR)
*
        IF Y.LIMIT.LIAB THEN
            LOOP
                REMOVE Y.CHECK.ID FROM Y.LIMIT.LIAB SETTING YLIM.INDEX
            WHILE Y.CHECK.ID
                GOSUB ADD.TO.LIST
            REPEAT
            IF NOT(Y.LIST.UP) THEN
                Y.ID.LIST<-1> = Y.SPARE.ID
            END
        END
    END
    
RETURN
**** =============================================================== ****
ADD.TO.LIST:
*--------------------
* Add the limits from the LIMIT.LIABILITY of the customer based on the nature of the LIMIT record.
* If the incoming limit is a new limit key, then call the LimitIdProcess routine to get the details of the limit.
    IF Y.CHECK.ID[1,2] EQ "LI" THEN
        LIMIT.ID.COMPONENTS = ""
        LIMIT.ID.COMPOSED = ""
        SPARE = ""
        ERR = ""
        SPARE<1> = LOWER(R.LIM.ALT.KEY)
        LI.Config.LimitIdProcess(Y.CHECK.ID, LIMIT.ID.COMPONENTS, LIMIT.ID.COMPOSED, SPARE, ERR)
        IF LIMIT.ID.COMPONENTS<9> NE "YES" THEN ;* When not joint liable, then form the id as LimitId.CustId
            Y.ID.LIST<-1> = Y.CHECK.ID:'.':Y.CUST.ID
        END ELSE
            Y.ID.LIST<-1> = Y.CHECK.ID ;* else keep as limit id.
        END
        Y.LIST.UP = 1
    END ELSE
        IF INDEX(Y.CHECK.ID,'.',3) THEN
            Y.ID.LIST<-1> = Y.CHECK.ID
            Y.LIST.UP = 1
        END ELSE
            IF Y.LIAB.CUST EQ 1 THEN
                IF NOT(Y.LIAB.OTH) THEN
                    Y.ID.LIST<-1> = Y.CHECK.ID:'.':FIELD(Y.CHECK.ID, '.',1);* Limit record present in the Limit liability record is not a liability customer ,
                END ELSE                                                    ;* hence on reading the LIMIT.TXNS the id is amended with the first part of the limit.
                    Y.ID.LIST<-1> = Y.CHECK.ID
                END
                Y.LIST.UP = 1
            END ELSE
                IF Y.SPARE.ID = "" THEN
                    IF NOT(Y.LIAB.OTH) THEN
                        Y.SPARE.ID = Y.CHECK.ID:'.':FIELD(Y.CHECK.ID, '.',1) ;* Limit record present in the Limit liability record is not a liability customer ,
                    END ELSE                                                    ;* hence on reading the LIMIT.TXNS the id is amended with the first part of the limit.
                        Y.SPARE.ID = Y.CHECK.ID
                    END
                END
            END
        END
    END
       
RETURN
**** =============================================================== ****
BUILD.SEL:
*--------------------
*
**** Build select Limit lines file depending on the operand...
*
* Replace the keyword NULL with '' in the user list. This allows the
* user to enter EQ NULL instead of GT 0 or whatever.
*
    LOOP LOCATE 'NULL' IN Y.WRK.CHK.VALUE<1,1,1> SETTING D ELSE D = 0 UNTIL D = 0
        Y.WRK.CHK.VALUE<1,1,D> = ''
    REPEAT
*
* Build the selection criteria according to the operand.
*
    BEGIN CASE
        CASE Y.WRK.OPERAND = 1    ;* EQ
            IF Y.WRK.CHK.VALUE<1,1,1> EQ 'ALL' THEN
                Y.SEL.CRITERIA<-1> = ' ':Y.FIELD.NAME: ' NE "" '
            END ELSE
                Y.SEL.CRITERIA<-1> = ' '
                CONNECTION = ''
                LOOP REMOVE UD FROM Y.WRK.CHK.VALUE SETTING D
                    Y.SEL.CRITERIA:= CONNECTION: Y.FIELD.NAME: ' = ': SQ: UD: SQ
                    CONNECTION = ' OR '
                UNTIL D = 0       ;* NO MORE TO REMOVE
                REPEAT
            END
*
        CASE Y.WRK.OPERAND = 2    ;* RG
            RG1 = Y.WRK.CHK.VALUE<1,1,1>
            RG2 = Y.WRK.CHK.VALUE<1,1,2>
            IF NOT(NUM(RG1)) THEN
                RG1 = SQ: RG1: SQ
            END
            IF NOT(NUM(RG2)) THEN
                RG2 = SQ: RG2: SQ
            END
*
            Y.SEL.CRITERIA<-1> = Y.FIELD.NAME: ' => ':  RG1: ' AND '
            Y.SEL.CRITERIA:=     Y.FIELD.NAME: ' <= ':  RG2
*
        CASE Y.WRK.OPERAND = 10   ;* NR
            RG1 = Y.WRK.CHK.VALUE<1,1,1>
            RG2 = Y.WRK.CHK.VALUE<1,1,2>
            IF NOT(NUM(RG1)) THEN
                RG1 = SQ: RG1: SQ
            END
            IF NOT(NUM(RG2)) THEN
                RG2 = SQ: RG2: SQ
            END
            Y.SEL.CRITERIA<-1> = Y.FIELD.NAME: ' < ': RG1: ' OR '
            Y.SEL.CRITERIA:=     Y.FIELD.NAME: ' > ': RG2
*
        CASE Y.WRK.OPERAND = 5    ;* NE
            Y.SEL.CRITERIA<-1> = ' '
            CONNECTION = ''
            LOOP REMOVE UD FROM Y.WRK.CHK.VALUE SETTING D
                Y.SEL.CRITERIA:= CONNECTION: Y.FIELD.NAME: ' NE ': SQ: UD: SQ
                CONNECTION = ' AND '
            UNTIL D = 0 ;* NO MORE TO REMOVE
            REPEAT
        CASE 1
            PERFORM.OPERANDS = 'EQ,XX,LT,GT,NE,LIKE,UNLIKE,LE,GE,XX'
            Y.SEL.CRITERIA<-1> = Y.FIELD.NAME: ' ': FIELD(PERFORM.OPERANDS,',',Y.WRK.OPERAND)
            Y.SEL.CRITERIA    := ' ': SQ: Y.WRK.CHK.VALUE: SQ
    END CASE
*
RETURN
**** =============================================================== ****
PROCESS.LIM.LINES:
*----------------
**** Customer record has to be read and checked whether the customer
**** is a part of a liability group or the head of a group or a stand
**** alone customer.
    Y.CUST.ID = FIELD(Y.LINE.ID,'.',1)
    Y.LIAB.CUST = ""
    Y.LIST.UP = ""
    Y.SPARE.ID = ""
    custId = Y.CUST.ID
    custParent = ''
* get the customer liability by calling customer service api.
    CALL CustomerService.getParent(custId, custParent)
*
    IF custParent<Parent.customerLiability> EQ '' THEN
        Y.LIAB.CUST = 1
    END ELSE
        IF custParent<Parent.customerLiability> EQ Y.CUST.ID THEN
            Y.LIAB.CUST = 2
        END
    END

    IF Y.LIAB.CUST THEN
        Y.LIMIT.LINES = ''
        LL.ERR = ''
        LI.Config.LimitLinesRead(Y.LINE.ID, Y.LIMIT.LINES, LL.ERR)
        IF Y.LIMIT.LINES THEN
            LOOP
                REMOVE Y.CHECK.ID FROM Y.LIMIT.LINES SETTING YLIM.INDEX
            WHILE Y.CHECK.ID
                IF INDEX(Y.CHECK.ID,'.',3) THEN
                    Y.ID.LIST<-1> = Y.CHECK.ID
                    Y.LIST.UP = 1
                END ELSE
                    IF Y.LIAB.CUST EQ 1 THEN
                        Y.ID.LIST<-1> = Y.CHECK.ID
                        Y.LIST.UP = 1
                    END ELSE
                        IF Y.SPARE.ID = "" THEN
                            Y.SPARE.ID = Y.CHECK.ID
                        END
                    END
                END
            REPEAT
            IF NOT(Y.LIST.UP) THEN
                Y.ID.LIST<-1> = Y.SPARE.ID
            END
        END
    END
RETURN
*=================================================================
*
SEL.LIMIT:
*----------------
*
* Build selection criteria into sentence (use voc paragraph in case
* sentence exceeds maximum line length).
*
* Modified below code to avoid writing into the &SAVEDLISTS& file on execution of LIAB enquiry
    IF NOT(Y.ID.LIST) THEN
        GOTO SEL.LIMIT.END
    END
*
* Add the other selection criteria to the select command
*
    IF Y.SEL.CRITERIA THEN
        CONNECTION = 'WITH'
        LOOP REMOVE SC FROM Y.SEL.CRITERIA SETTING D UNTIL SC = ''
            Y.SEL.COMMAND:= ' ':CONNECTION: ' ': SC
            CONNECTION = '& WITH'
        REPEAT
    END

*
    THE.LIST = dasLimitSelCriteria
    THE.ARGS = Y.SEL.COMMAND:" BY @ID"
    EB.DataAccess.Das('LIMIT',THE.LIST,THE.ARGS,'')

    IF NOT(THE.LIST) THEN
        EB.Reports.setEnqError('SELECT ON ':YF.LIMIT:' FAILED')
        GOTO PROGRAM.ABORT
    END

    Y.ID.LIST = ""
    LOOP
        REMOVE Y.CHECK.ID FROM THE.LIST SETTING SEL.POS
    WHILE Y.CHECK.ID:SEL.POS
        IF INDEX(Y.CHECK.ID,'.',3) THEN
            Y.ID.LIST<-1> = Y.CHECK.ID
        END ELSE
            Y.ID.LIST<-1> = Y.CHECK.ID:'.':FIELD(Y.CHECK.ID, '.',1)
        END
    REPEAT
SEL.LIMIT.END:
RETURN
**** =============================================================== ****
PROGRAM.ABORT:
*
RETURN TO PROGRAM.ABORT
*
*-----------------------------------------------------------------
END
